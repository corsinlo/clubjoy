{% comment %}
    Google Reviews Section
    Displays Google reviews in a vertical layout with load more functionality
    Uses existing Google Maps API from the page
  {% endcomment %}

  {% if product.metafields.custom.place_id != blank %}
  <div class="google-reviews"
       data-section-id="{{ section.id }}"
       data-place-id="{{ product.metafields.custom.place_id }}">
    <div class="google-reviews__container">
      <div class="google-reviews__reviews" id="reviews-container-{{ section.id }}">
        <!-- Reviews will be loaded here -->
        <div class="google-reviews__loading">Loading reviews...</div>
      </div>

      <div class="google-reviews__load-more" id="load-more-container-{{ section.id }}" style="display: none;">
        <button class="google-reviews__load-more-btn" id="load-more-btn-{{ section.id }}">
          Load More Reviews
        </button>
      </div>
    </div>

    <!-- Star Rating Blocks -->
    {% for block in section.blocks %}
      {% case block.type %}
        {% when 'star_rating' %}
          <div class="star-rating-block"
               id="star-rating-{{ block.id }}"
               data-block-id="{{ block.id }}"
               style="text-align: {{ block.settings.alignment }};">
            {% if block.settings.title != blank %}
              <h3 class="star-rating-block__title">{{ block.settings.title }}</h3>
            {% endif %}
            <div class="star-rating-block__stars"
                 data-star-size="{{ block.settings.star_size }}"
                 data-star-color="{{ block.settings.star_color }}">
              <div class="star-rating-loading">Loading rating...</div>
            </div>
            <div class="star-rating-block__details" style="display: none;">
              <span class="star-rating-value"></span>
              <span class="star-rating-text">out of 5 stars</span>
              <span class="star-rating-count"></span>
            </div>
          </div>
      {% endcase %}
    {% endfor %}
  </div>
  {% endif %}

  <style>
    .google-reviews {
      padding: 60px 0;
      background: {{ section.settings.background_color }};
    }

    .google-reviews__container {
      max-width: 800px;
      margin: 0 auto;
      padding: 0 20px;
    }

    .google-reviews__reviews {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      width: 100%;
      margin-bottom: 40px;
    }

    .review-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      min-height: auto;
      position: relative;
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .review-card.loading {
      opacity: 0;
      transform: translateY(20px);
    }

    .review-card__header {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      flex-shrink: 0;
    }

    .review-card__author-section {
      display: flex;
      align-items: center;
      flex: 1;
    }

    .review-card__author {
      font-weight: 600;
      color: #333;
      font-size: 16px;
      line-height: 1.3;
      margin-right: 12px;
    }

    .review-card__rating {
      color: #ffc107;
      font-size: 16px;
      margin-right: 12px;
    }

    .review-card__google-logo {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
    }

    .review-card__text {
      color: #666;
      line-height: 1.6;
      margin-bottom: 12px;
      font-size: 15px;
    }

    .review-card__text.collapsed {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .review-card__text-translated {
      color: #555;
      line-height: 1.6;
      margin-bottom: 12px;
      font-size: 14px;
      font-style: italic;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 3px solid #4285f4;
      display: none;
    }

    .review-card__text-translated.show {
      display: block;
    }

    .review-card__actions {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
    }

    .review-card__expand-btn,
    .review-card__translate-btn {
      background: none;
      border: none;
      color: #4285f4;
      font-size: 14px;
      cursor: pointer;
      padding: 0;
      text-align: left;
    }

    .review-card__expand-btn:hover,
    .review-card__translate-btn:hover {
      text-decoration: underline;
    }

    .review-card__translate-btn.loading {
      color: #999;
      cursor: wait;
    }

    .review-card__date {
      font-size: 14px;
      color: #999;
      text-align: left;
    }

    .google-reviews__load-more {
      text-align: center;
    }

    .google-reviews__load-more-btn {
      background: {{ section.settings.heading_color | default: '#333333' }};
      color: white;
      border: none;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }

    .google-reviews__load-more-btn:hover {
      background: #555;
      transform: translateY(-2px);
    }

    .google-reviews__load-more-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .google-reviews__loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .google-reviews__error {
      text-align: center;
      padding: 40px;
      color: #e74c3c;
      background: #fdf2f2;
      border-radius: 8px;
    }

    /* Star Rating Block Styles */
    .star-rating-block {
      padding: 30px 20px;
      margin: 20px 0;
    }

    .star-rating-block__title {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }

    .star-rating-block__stars {
      margin-bottom: 10px;
    }

    .star-rating-block__details {
      font-size: 0.95rem;
      color: #666;
      margin-top: 8px;
    }

    .star-rating-value {
      font-weight: 600;
      color: #333;
      margin-right: 5px;
    }

    .star-rating-count {
      margin-left: 10px;
      font-style: italic;
    }

    .star-rating-loading {
      color: #666;
      font-style: italic;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .google-reviews__reviews {
        gap: 12px;
      }

      .review-card {
        padding: 16px;
      }

      .review-card__author {
        font-size: 14px;
      }

      .review-card__rating {
        font-size: 14px;
      }

      .review-card__text {
        font-size: 14px;
      }

      .review-card__google-logo {
        width: 16px;
        height: 16px;
      }
    }
  </style>

  <script>
    class GoogleReviews {
      constructor(sectionId) {
        this.sectionId = sectionId;
        this.container = document.getElementById(`reviews-container-${sectionId}`);
        this.loadMoreContainer = document.getElementById(`load-more-container-${sectionId}`);
        this.loadMoreBtn = document.getElementById(`load-more-btn-${sectionId}`);
        this.sectionElement = document.querySelector(`[data-section-id="${sectionId}"]`);
        this.placeId = this.sectionElement.dataset.placeId;
        this.maxRetries = 20;
        this.retryDelay = 500;

        // Review management
        this.allReviews = [];
        this.displayedReviews = 0;
        this.reviewsPerLoad = 5;
        this.placeRating = null;
        this.placeReviewsCount = null;

        this.init();
      }

      async init() {
        await this.waitForGoogleMaps();
        await this.loadGoogleReviews();
        this.setupLoadMore();
        this.setupInteractions();
        this.updateStarRatingBlocks();
      }

      setupLoadMore() {
        this.loadMoreBtn.addEventListener('click', () => {
          this.loadMoreReviews();
        });
      }

      setupInteractions() {
        // Use event delegation for dynamically added buttons
        this.container.addEventListener('click', (e) => {
          if (e.target.classList.contains('review-card__expand-btn')) {
            const textElement = e.target.closest('.review-card').querySelector('.review-card__text');
            const isCollapsed = textElement.classList.contains('collapsed');

            if (isCollapsed) {
              textElement.classList.remove('collapsed');
              e.target.textContent = 'Show less';
            } else {
              textElement.classList.add('collapsed');
              e.target.textContent = 'Read more';
            }
          }

          if (e.target.classList.contains('review-card__translate-btn')) {
            this.handleTranslate(e.target);
          }
        });
      }

      async handleTranslate(button) {
        if (button.classList.contains('loading')) return;

        const reviewCard = button.closest('.review-card');
        const translatedElement = reviewCard.querySelector('.review-card__text-translated');
        const originalText = reviewCard.querySelector('.review-card__text').textContent;

        if (translatedElement.classList.contains('show')) {
          // Hide translation
          translatedElement.classList.remove('show');
          button.textContent = 'Translate to English';
          return;
        }

        // Show translation
        if (translatedElement.textContent.trim() === '') {
          // Need to translate first
          button.classList.add('loading');
          button.textContent = 'Translating...';

          try {
            const translation = await this.translateText(originalText);
            translatedElement.textContent = translation;
          } catch (error) {
            console.error('Translation error:', error);
            translatedElement.textContent = 'Translation unavailable';
          }

          button.classList.remove('loading');
          button.textContent = 'Hide translation';
        } else {
          button.textContent = 'Hide translation';
        }

        translatedElement.classList.add('show');
      }

      async translateText(text) {
        // Simple translation using Google Translate
        try {
          const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=en&dt=t&q=${encodeURIComponent(text)}`);
          const data = await response.json();
          return data[0][0][0] || text;
        } catch (error) {
          console.error('Translation API error:', error);
          return 'Translation not available';
        }
      }

      async waitForGoogleMaps() {
        let attempts = 0;

        while (attempts < this.maxRetries) {
          // Check if Google Maps API is available
          if (typeof google !== 'undefined' && google.maps) {
            // Additional check to ensure Places library is available for import
            try {
              await google.maps.importLibrary("places");
              console.log('‚úÖ Google Maps API and Places library found');
              return;
            } catch (placesError) {
              console.log(`‚ö†Ô∏è Google Maps API found but Places library not ready: ${placesError.message}`);
            }
          }

          console.log(`‚è≥ Waiting for Google Maps API... (attempt ${attempts + 1}/${this.maxRetries})`);
          await new Promise(resolve => setTimeout(resolve, this.retryDelay));
          attempts++;
        }

        // If we still don't have the API, try to load it ourselves as fallback
        console.log('üîÑ Attempting to load Google Maps API as fallback...');
        try {
          await this.loadGoogleMapsAPI();
          console.log('‚úÖ Google Maps API loaded as fallback');
          return;
        } catch (fallbackError) {
          console.error('üí• Fallback API loading failed:', fallbackError);
          throw new Error('Google Maps API not found. Make sure the map component with API key is present on this page, or check if there are API quota issues.');
        }
      }

      async loadGoogleMapsAPI() {
        return new Promise((resolve, reject) => {
          // Check if script is already being loaded
          if (document.querySelector('script[src*="googleapis.com/maps"]')) {
            // Wait for existing script to load
            const checkGoogle = () => {
              if (typeof google !== 'undefined' && google.maps) {
                resolve();
              } else {
                setTimeout(checkGoogle, 100);
              }
            };
            checkGoogle();
            return;
          }

          // Load the API script as fallback
          const script = document.createElement('script');
          script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyCQ3bPzVGn7UbU6BBDYHX6mB4xjb6tAR5o&libraries=places';
          script.async = true;
          script.defer = true;

          script.onload = () => {
            console.log('üìç Fallback Google Maps API loaded successfully');
            resolve();
          };

          script.onerror = () => {
            reject(new Error('Failed to load Google Maps API script'));
          };

          document.head.appendChild(script);
        });
      }

      async loadGoogleReviews() {
        console.log('üöÄ Loading Google Reviews for Place ID:', this.placeId);

        try {
          if (typeof google === 'undefined' || !google.maps) {
            throw new Error('Google Maps API not available');
          }

          console.log('üìç Using Google Maps API, importing Places library...');

          const { Place } = await google.maps.importLibrary("places");

          console.log('üè¢ Creating Place instance for:', this.placeId);

          // Validate place ID format
          if (!this.placeId || this.placeId.trim() === '') {
            throw new Error('Invalid or empty Place ID');
          }

          // Create place without language preference to get original language
          const place = new Place({
            id: this.placeId.trim()
          });

          console.log('üîç Fetching place details with reviews...');

          await place.fetchFields({
            fields: ['reviews', 'displayName', 'rating']
          });

          // Store place rating info for star rating blocks
          this.placeRating = place.rating;
          this.placeReviewsCount = place.reviews?.length || 0;

          console.log('üì¶ Place Data:', {
            name: place.displayName,
            rating: this.placeRating,
            reviewsCount: this.placeReviewsCount
          });

          if (place.reviews && place.reviews.length > 0) {
            console.log('‚úÖ Found', place.reviews.length, 'reviews');

            // Store all reviews in their original language
            this.allReviews = place.reviews.map((review, index) => {
              console.log(`Processing review ${index}:`, review);

              // Get the original text - try to get the untranslated version
              let reviewText = '';
              if (review.originalText) {
                reviewText = review.originalText;
              } else if (review.text && typeof review.text === 'object' && review.text.text) {
                reviewText = review.text.text;
              } else if (review.text) {
                reviewText = review.text;
              } else if (review.content) {
                reviewText = review.content;
              } else {
                reviewText = 'No review text available';
              }

              return {
                author_name: review.authorAttribution?.displayName || 'Anonymous',
                rating: review.rating || 0,
                text: reviewText,
                time: review.publishTime || Date.now()
              };
            });

            console.log('All reviews stored:', this.allReviews);

            // Display first batch of 5 reviews
            this.displayInitialReviews();

            // Show load more button if there are more than 5 reviews
            if (this.allReviews.length > this.reviewsPerLoad) {
              this.loadMoreContainer.style.display = 'block';
              this.updateLoadMoreButton();
            }

          } else {
            console.warn('‚ö†Ô∏è No reviews found for this place');
            this.showMessage('No reviews available for this location.');
          }

        } catch (error) {
          console.error('üí• Error loading Google reviews:', error);
          console.error('üîç Error details:', {
            message: error.message,
            stack: error.stack,
            placeId: this.placeId,
            googleAvailable: typeof google !== 'undefined',
            mapsAvailable: typeof google !== 'undefined' && !!google.maps,
            placesLibrary: 'Check if Places library can be imported'
          });

          // More specific error handling
          if (error.message.includes('Google Maps API not available')) {
            this.showError('Google Maps API required. Please ensure the map component is present on this page.');
          } else if (error.message.includes('Invalid or empty Place ID')) {
            this.showError('Invalid Place ID. Please check the Place ID metafield for this product.');
          } else if (error.message.includes('Place not found') || error.message.includes('INVALID_REQUEST')) {
            this.showError(`Place not found. The Place ID "${this.placeId}" may be incorrect or the place may not exist.`);
          } else if (error.message.includes('quota') || error.message.includes('OVER_QUERY_LIMIT')) {
            this.showError('Google Places API quota exceeded. Please try again later.');
          } else if (error.message.includes('permission') || error.message.includes('REQUEST_DENIED')) {
            this.showError('Google Places API access denied. Please check API key permissions.');
          } else {
            this.showError(`Unable to load reviews: ${error.message}. Check console for details.`);
          }
        }
      }

      displayInitialReviews() {
        // Display first 5 reviews
        const initialBatch = this.allReviews.slice(0, this.reviewsPerLoad);
        this.container.innerHTML = '';
        this.renderNewReviews(initialBatch);
        this.displayedReviews = initialBatch.length;
      }

      loadMoreReviews() {
        const nextBatch = this.allReviews.slice(
          this.displayedReviews,
          this.displayedReviews + this.reviewsPerLoad
        );

        if (nextBatch.length === 0) {
          return;
        }

        // Add new review cards with animation
        this.renderNewReviews(nextBatch);

        this.displayedReviews += nextBatch.length;

        // Update load more button
        this.updateLoadMoreButton();
      }

      updateLoadMoreButton() {
        const hasMoreReviews = this.displayedReviews < this.allReviews.length;

        if (!hasMoreReviews) {
          this.loadMoreBtn.textContent = 'All Reviews Loaded';
          this.loadMoreBtn.disabled = true;
        } else {
          const remaining = this.allReviews.length - this.displayedReviews;
          this.loadMoreBtn.textContent = `Load ${Math.min(remaining, this.reviewsPerLoad)} More Reviews`;
          this.loadMoreBtn.disabled = false;
        }
      }

      showMessage(message) {
        this.container.innerHTML = `<div class="google-reviews__loading">${message}</div>`;
      }

      showError(message) {
        this.container.innerHTML = `<div class="google-reviews__error">${message}</div>`;
      }

      isTextLong(text, maxLength = 200) {
        return text.length > maxLength;
      }

      isNonEnglish(text) {
        // Enhanced detection for non-English text
        const nonEnglishRegex = /[^\x00-\x7F]/;
        const italianWords = /\b(molto|bellissimo|fantastico|ottimo|buono|grazie|perfetto|consiglio|esperienza)\b/i;
        const frenchWords = /\b(tr√®s|magnifique|excellent|merci|parfait|exp√©rience|recommande)\b/i;
        const spanishWords = /\b(muy|excelente|fant√°stico|gracias|perfecto|experiencia|recomiendo)\b/i;
        const germanWords = /\b(sehr|ausgezeichnet|fantastisch|danke|perfekt|erfahrung|empfehle)\b/i;

        return nonEnglishRegex.test(text) ||
               italianWords.test(text) ||
               frenchWords.test(text) ||
               spanishWords.test(text) ||
               germanWords.test(text) ||
               text.includes('√®') || text.includes('√©') || text.includes('√†') ||
               text.includes('√≤') || text.includes('√¨') || text.includes('√π') ||
               text.includes('√±') || text.includes('√ß') || text.includes('√º') ||
               text.includes('√§') || text.includes('√∂') || text.includes('√ü');
      }

      renderNewReviews(reviews) {
        const reviewsHtml = reviews.map(review => {
          const stars = '‚òÖ'.repeat(review.rating) + '‚òÜ'.repeat(5 - review.rating);
          const date = new Date(review.time).toLocaleDateString();
          const isLongText = this.isTextLong(review.text);
          const showTranslate = this.isNonEnglish(review.text);

          const googleLogoSvg = `<svg class="review-card__google-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
            <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
            <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
            <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
          </svg>`;

          return `
            <div class="review-card loading">
              <div class="review-card__header">
                <div class="review-card__author-section">
                  <div class="review-card__author">${review.author_name}</div>
                  <div class="review-card__rating">${stars}</div>
                  ${googleLogoSvg}
                </div>
              </div>
              <div class="review-card__text ${isLongText ? 'collapsed' : ''}">${review.text}</div>
              <div class="review-card__text-translated"></div>
              <div class="review-card__actions">
                ${isLongText ? '<button class="review-card__expand-btn">Read more</button>' : ''}
                ${showTranslate ? '<button class="review-card__translate-btn">Translate to English</button>' : ''}
              </div>
              <div class="review-card__date">${date}</div>
            </div>
          `;
        }).join('');

        this.container.insertAdjacentHTML('beforeend', reviewsHtml);

        // Trigger animation for new cards
        setTimeout(() => {
          const newCards = this.container.querySelectorAll('.review-card.loading');
          newCards.forEach((card, index) => {
            setTimeout(() => {
              card.classList.remove('loading');
            }, index * 100);
          });
        }, 50);
      }

      updateStarRatingBlocks() {
        // Find all star rating blocks in this section
        const starRatingBlocks = this.sectionElement.querySelectorAll('.star-rating-block');

        starRatingBlocks.forEach(block => {
          const starsContainer = block.querySelector('.star-rating-block__stars');
          const detailsContainer = block.querySelector('.star-rating-block__details');
          const loadingText = block.querySelector('.star-rating-loading');

          if (this.placeRating !== null) {
            // Get custom settings for this block
            const starSize = starsContainer.dataset.starSize || '24';
            const starColor = starsContainer.dataset.starColor || '#ffd700';

            // Create star display
            const fullStars = Math.floor(this.placeRating);
            const hasHalfStar = this.placeRating % 1 >= 0.5;
            const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);

            let starsHTML = '';

            // Full stars
            for (let i = 0; i < fullStars; i++) {
              starsHTML += `<span class="star filled" style="font-size: ${starSize}px; color: ${starColor};">‚òÖ</span>`;
            }

            // Half star
            if (hasHalfStar) {
              starsHTML += `<span class="star half" style="font-size: ${starSize}px; color: ${starColor};">‚òÜ</span>`;
            }

            // Empty stars
            for (let i = 0; i < emptyStars; i++) {
              starsHTML += `<span class="star empty" style="font-size: ${starSize}px; color: #ddd;">‚òÜ</span>`;
            }

            // Update the display
            starsContainer.innerHTML = starsHTML;

            // Update details
            if (detailsContainer) {
              const ratingValue = detailsContainer.querySelector('.star-rating-value');
              const ratingCount = detailsContainer.querySelector('.star-rating-count');

              if (ratingValue) ratingValue.textContent = this.placeRating.toFixed(1);
              if (ratingCount) ratingCount.textContent = `(${this.placeReviewsCount} review${this.placeReviewsCount !== 1 ? 's' : ''})`;

              detailsContainer.style.display = 'block';
            }

            // Hide loading text
            if (loadingText) loadingText.style.display = 'none';

          } else {
            // Show error state
            if (loadingText) {
              loadingText.textContent = 'Rating unavailable';
              loadingText.style.color = '#e74c3c';
            }
          }
        });
      }
    }

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      new GoogleReviews('{{ section.id }}');
    });
  </script>

  {% schema %}
  {
    "name": "Google Reviews",
    "settings": [
      {
        "type": "paragraph",
        "content": "Google Reviews are automatically loaded using your Google Place ID. This section uses the Google Maps API that's already loaded by your map component - no additional API key needed."
      },
      {
        "type": "color",
        "id": "background_color",
        "label": "Background Color",
        "default": "#f8f9fa"
      },
      {
        "type": "color",
        "id": "heading_color",
        "label": "Button Color",
        "default": "#333333"
      }
    ],
    "blocks": [
      {
        "type": "star_rating",
        "name": "Star Rating Only",
        "settings": [
          {
            "type": "text",
            "id": "title",
            "label": "Title",
            "default": "Customer Rating"
          },
          {
            "type": "select",
            "id": "alignment",
            "label": "Alignment",
            "options": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ],
            "default": "center"
          },
          {
            "type": "range",
            "id": "star_size",
            "min": 16,
            "max": 32,
            "step": 2,
            "unit": "px",
            "label": "Star Size",
            "default": 24
          },
          {
            "type": "color",
            "id": "star_color",
            "label": "Star Color",
            "default": "#ffd700"
          }
        ]
      }
    ],
    "presets": [
      {
        "name": "Google Reviews"
      }
    ]
  }
  {% endschema %}